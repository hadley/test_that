% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mock-object.R
\name{mock}
\alias{$.mock}
\alias{length.mock}
\alias{mock}
\title{Create a mock object.}
\usage{
mock(..., cycle = FALSE, envir = parent.frame())

\method{$}{mock}(m, n)

\method{length}{mock}(m)
}
\arguments{
\item{...}{Values returned upon subsequent calls.}

\item{cycle}{Whether to cycle over the return values. If \code{FALSE},
will fail if called too many times.}

\item{envir}{Where to evaluate the expressions being returned.}

\item{m}{A \code{\link{mock}} object.}

\item{n}{List name.}
}
\value{
A mock object.

\code{calls} is a list of call signatures and \code{args} is
        a respective list of lists of arguments' values.

Number of calls invoked on \code{m}.
}
\description{
Mock object's primary use is to record calls that are made on the
mocked function.

\code{$.mock} returns one of two lists: \code{calls} or \code{args}.
}
\details{
Optionally values/expressions can be passed via \code{...} for the
mock object to return them upon subsequent calls. Expressions are
evaluated in environment \code{envir} before being returned. If no
value is passed in \code{...} then \code{NULL} is returned.

Passing an expression or a function call via \code{...} is also a
way to implement side effects: keep track of the state of code
under testing, throw an exception when a condition is met, etc.
}
\examples{
m <- mock(1)
with_mock(summary = m, {
  expect_equal(summary(iris), 1)
  expect_length(m, 1)
  expect_call(m, 1, summary(iris))
  expect_equal(m$args[[1]], )
})

m <- mock()
m(x = 1)
m(y = 2)
expect_equal(length(m), 2)
expect_equal(m$calls[[1]], quote(m(x = 1)))
expect_equal(m$calls[[1]], quote(m(y = 2)))
}

