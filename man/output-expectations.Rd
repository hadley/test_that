% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expect-output.R
\name{output-expectations}
\alias{output-expectations}
\alias{expect_error}
\alias{expect_condition}
\alias{expect_message}
\alias{expect_warning}
\title{Expectation: does code produce errors/warnings/messages?}
\usage{
expect_error(object, regexp = NULL, class = NULL, ..., info = NULL,
  label = NULL)

expect_condition(object, regexp = NULL, class = NULL, ...,
  info = NULL, label = NULL)

expect_message(object, regexp = NULL, ..., all = FALSE, info = NULL,
  label = NULL)

expect_warning(object, regexp = NULL, ..., all = FALSE, info = NULL,
  label = NULL)
}
\arguments{
\item{object}{Object to test.

Supports limited unquoting to make it easier to generate readable failures
within a function or for loop. See \link{quasi_label} for more details.}

\item{regexp}{regular expression to test against.

If \code{NULL}, the default, asserts that there should be an output,
a messsage, a warning, or an error, but does not test for specific value.

If \code{NA}, asserts that there should be no output, messages, warnings,
or errors.}

\item{class}{Instead of supplying a regular expression, you can also supply
a class name. This is useful for "classed" conditions.}

\item{...}{Arguments passed on to \code{expect_match}
\describe{
  \item{all}{Should all elements of actual value match \code{regexp} (TRUE),
or does only one need to match (FALSE)}
  \item{perl}{logical.  Should Perl-compatible regexps be used?}
  \item{fixed}{logical.  If \code{TRUE}, \code{pattern} is a string to be
    matched as is.  Overrides all conflicting arguments.}
}}

\item{info}{Extra information to be included in the message. This argument
is soft-deprecated and should not be used in new code. Instead see
alternatives in \link{quasi_label}.}

\item{label}{Used to customise failure messages. For expert use only.}

\item{all}{For messages and warnings, do all need to match the \code{regexp}
(TRUE), or does only one need to match (FALSE)}
}
\value{
The first argument, invisibly. If \code{expect_error()} captures an
error, that is returned instead of the value.
}
\description{
Use \code{expect_message()} and \code{expect_warning()} to match specified outputs.
Use \code{expect_error()} or \code{expect_condition()} to match individual errors or
conditions.
}
\details{
Note that warnings are captured by a custom signal handler: this means
that \code{options(warn)} has no effect.
}
\section{Testing \code{message} vs \code{class}}{

When checking that code generates an error, it's important to check that the
error is the one you expect. There are two ways to do this. The first
way is the simplest: you just provide a \code{regexp} that match some fragment
of the error message. This is easy, but fragile, because the test will
fail if the error message changes (even if its the same error).

A more robust way is to test for the class of the error, if it has one.
You can learn more about custom conditions at
\url{https://adv-r.hadley.nz/conditions.html#custom-conditions}, but in
short, errors are S3 classes and you can generate a custom class and check
for it using \code{class} instead of \code{regexp}. Because this is a more reliable
check, you \code{expect_error()} will warn if the error has a custom class but
you are testing the message. Eliminate the warning by using \code{class} instead
of \code{regexp}.

If you are using \code{expect_error()} to check that an error message is
formatted in such a way that it makes sense to a human, we now recommend
using \code{\link[=verify_output]{verify_output()}} instead.
}

\examples{
# Messages ------------------------------------------------------------------

f <- function(x) {
  if (x < 0) message("*x* is already negative")
  -x
}
expect_message(f(-1))
expect_message(f(-1), "already negative")
expect_message(f(1), NA)

# You can use the arguments of grepl to control the matching
expect_message(f(-1), "*x*", fixed = TRUE)
expect_message(f(-1), "NEGATIVE", ignore.case = TRUE)

# Warnings --------------------------------------------------------------------
f <- function(x) {
  if (x < 0) warning("*x* is already negative")
  -x
}
expect_warning(f(-1))
expect_warning(f(-1), "already negative")
expect_warning(f(1), NA)

# You can use the arguments of grepl to control the matching
expect_warning(f(-1), "*x*", fixed = TRUE)
expect_warning(f(-1), "NEGATIVE", ignore.case = TRUE)

# Errors --------------------------------------------------------------------
f <- function() stop("My error!")
expect_error(f())
expect_error(f(), "My error!")

# You can use the arguments of grepl to control the matching
expect_error(f(), "my error!", ignore.case = TRUE)
}
\seealso{
Other expectations: \code{\link{comparison-expectations}},
  \code{\link{equality-expectations}},
  \code{\link{expect_length}}, \code{\link{expect_match}},
  \code{\link{expect_named}}, \code{\link{expect_null}},
  \code{\link{inheritance-expectations}},
  \code{\link{logical-expectations}}
}
\concept{expectations}
