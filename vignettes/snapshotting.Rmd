---
title: "Snapshot tests"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Snapshot tests}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
set.seed(1014)
```

The goal of a unit test is to record the expected output of a function using code. This is a powerful technique because because not only does it ensure that code doesn't change unexpectedly, it also expresses the desired behaviour in a way that a human can understand.

However, it's not always convenient to record the expected behaviour with code. Some challenges include:

-   Text output that includes many characters like quotes and newlines that require special handling in a string.

-   Output that is large, making it painful to define the reference output, and bloating the size of the test file and making it hard to navigate.

-   Binary formats like plots or images, which are very difficult to describe in code: i.e. the plot looks right, the error message is useful to a human, the print method uses colour effectively.

For these situations, testthat provides an alternative mechanism: snapshot tests. Instead of using code to describe expected output, snapshot tests (also known as [golden tests](https://ro-che.info/articles/2017-12-04-golden-tests)) record results in a separate human readable file. Snapshot tests in testthat are inspired primarily by [Jest](https://jestjs.io/docs/en/snapshot-testing), thanks to a number of very useful discussions with Joe Cheng.

```{r setup}
library(testthat)
```

```{r include = FALSE}
snapper <- testthat:::SnapshotReporter$new()
options(testthat.snapshotter = snapper)
```

## Basic workflow

We'll illustrate the basic workflow with a simple function that generates an HTML heading. The heading can optionally automatically an anchor that allows you to link to it on the page.

```{r}
bullets <- function(text, id = NULL) {
  paste0(
    "<ul", if (!is.null(id)) paste0(" id=\"", id, "\""), ">\n", 
    paste0("  <li>", text, "</li>\n", collapse = ""),
    "</ul>\n"
  )
}
cat(bullets(c("a", "b")))
```

Testing this simple function is relatively painful. To write the test you have to carefully escape the newlines and quotes. And when you re-read the test in the future, it's hard to tell exactly what's happening.

```{r}
test_that("bullets", {
  expect_equal(bullets("a"), "<ul>\n  <li>a</li>\n</ul>\n")
  expect_equal(bullets("a", "b"), "<ul id=\"b\">\n  <li>a</li>\n</ul>\n")
})
```

```{r include = FALSE}
snapper$start_file("snapshot-1", "test")
```

This is a great place to use snapshot testing. To do this we make two changes to our code: we use `expect_snapshot_output()` instead of `expect_equal()`, and wrap the call in `cat()` (like my first interactive example).

```{r}
test_that("bullets", {
  expect_snapshot_output(cat(bullets("a")))
  expect_snapshot_output(cat(bullets("a", "b")))
})
```

```{r, include = FALSE}
# Reset snapshot test
snapper$end_file()
snapper$start_file("snapshot-1", "test")
```

We we run the test for the first time, it automatically generates reference output, and prints it (so you can visually confirm that it's correct). The output is automatically saved in a `_snaps` in with a file name that matches your test file name --- e.g. if your test is `test-pizza.R` your snapshot will be saved in `test/testthat/_snaps/pizza.md`. As the file name suggests, this is a markdown file, which we'll talk about in a little bit.

If you run the test again, it'll pass if as long as the values are still correct:

```{r}
test_that("bullets", {
  expect_snapshot_output(cat(bullets("a")))
  expect_snapshot_output(cat(bullets("a", "b")))
})
```

```{r, include = FALSE}
# Reset snapshot test
snapper$end_file()
snapper$start_file("snapshot-1", "test")
```

If we do make a change, say to tweak the indenting, the test will fail:

```{r}
bullets <- function(text, id = NULL) {
  paste0(
    "<ul", if (!is.null(id)) paste0(" id=\"", id, "\""), ">\n", 
    paste0("<li>", text, "</li>\n", collapse = ""),
    "</ul>\n"
  )
}
test_that("bullets", {
  expect_snapshot_output(cat(bullets("a")))
  expect_snapshot_output(cat(bullets("a", "b")))
})
```

If this is a deliberate change, you can follow the hint in the message and update the snapshots by running `snapshot_accept()`; otherwise you can fix the bug and your tests will pass once more.

### Snapshot format

Snapshots are recorded using a subset of markdown. You might wonder why we use markdown? It's important that snapshots be readable by humans, because humans have to look at it during code reviews. Reviewers often don't run your code but still want to understand the changes.

Here's the snapshot file generated by the test above:

``` {.md}
## bullets

    <ul>
      <li>a</li>
    </ul>
  
---

    <ul id="b">
      <li>a</li>
    </ul>
```

It's simple but illustrates the main components:

-   Each test starts with `## {test name}`

-   Each expectation is indented by four spaces, so it's formatted as code (if rendered).

-   Expectations within a test are divided by `---`, a horizontal rule.

## Other types of snapshot

`expect_snapshot_output()` is probably the most commonly used snapshot function but there are a few other variants that are useful in other case.

-   `expect_snapshot_error()` works like `expect_snapshot_output()` but captures an error message, rather than console output.

-   `expect_snapshot_value()` checks that the value of any R object stays the same. It has a number of serialisation approaches built-in that offer a tradeoff between accuracy and human readability.

-   `expect_snapshot_condition()` captures a complete condition object.

## Previous work

This is not the first time that testthat has attempt to provide snapshot testing (although it's the first time I knew what other languages called them). This section describes some of the previous attempts and why we believe the new approach is better.

-   `verify_output()` has three main drawbacks.

    -   You have to supply a path where the output will be saved. This seems like a small issue, but it introduces a suprising amount of friction

    -   It overwrites files on disk meaning that you must use git in order to use it, and you must use git to

    -   It is relatively coarse grained, which means.

-   `expect_known_output()` is finer grained version of `verify_output()` that captures output from a single function. The requirement to produce a path for each individual expectation makes it evern more painful to use.

-   `expect_know_value()` and `expect_known_hash()` have all the disadvantages of `expect_known_output()`, but also produce binary output meaning that you can't easily review test differences in pull requests.

```{r, include = FALSE}
snapper$snaps_cleanup()
```
